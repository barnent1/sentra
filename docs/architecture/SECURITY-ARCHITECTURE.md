# Sentra AI Agent Security Architecture

**Document Version:** 1.0
**Last Updated:** November 12, 2025
**Author:** Glen Barnhardt with Claude Code
**Status:** APPROVED - Implementation Starting This Week
**Approval:** Glen Barnhardt (Technical Lead)

---

## Executive Summary

This document defines Sentra's security architecture for running AI agents that execute untrusted code. Based on comprehensive research into Claude Code for Web's production architecture, Sentra implements a pragmatic 3-phase approach that balances security, engineering effort, and time-to-market.

### Key Decisions

1. **Phase 1 (THIS WEEK):** Docker containerization on GitHub Actions
2. **Phase 2 (Weeks 2-4):** Credential proxy service
3. **Phase 3 (Q1 2026):** gVisor migration with custom infrastructure
4. **Infrastructure:** GitHub Actions (Phases 1-2), Custom runners (Phase 3)
5. **SDK:** Anthropic Python SDK directly (not CLI subprocess)

### Security Posture

- **Before:** UNACCEPTABLE (critical credential theft risk)
- **After Phase 1:** ACCEPTABLE for internal testing (60-70% risk reduction)
- **After Phase 2:** ACCEPTABLE for limited production (85% risk reduction)
- **After Phase 3:** INDUSTRY-LEADING (95%+ risk reduction)

---

## Table of Contents

1. [Threat Model](#threat-model)
2. [Phase 1: Docker Containerization](#phase-1-docker-containerization)
3. [Phase 2: Credential Proxy Service](#phase-2-credential-proxy-service)
4. [Phase 3: gVisor Migration](#phase-3-gvisor-migration)
5. [Infrastructure Architecture](#infrastructure-architecture)
6. [SDK Implementation](#sdk-implementation)
7. [Security Testing](#security-testing)
8. [Timeline and Milestones](#timeline-and-milestones)
9. [References](#references)

---

## Threat Model

### Attack Surface

Sentra's AI agents run code generated by Claude (Anthropic's LLM) on GitHub Actions infrastructure. This creates several attack vectors:

**Primary Threats:**

1. **Prompt Injection → Credential Theft**
   - Attacker crafts malicious GitHub issue
   - Claude generates code that exfiltrates `$GITHUB_TOKEN` or `$ANTHROPIC_API_KEY`
   - Attacker gains full repository access
   - **Likelihood:** HIGH (jailbreaks improve monthly)
   - **Impact:** CRITICAL (full account compromise)

2. **Filesystem Compromise**
   - Agent code reads sensitive files (`.env`, SSH keys, AWS credentials)
   - Previous job's temporary files contain secrets
   - **Likelihood:** MEDIUM
   - **Impact:** CRITICAL

3. **Cross-Job Contamination**
   - Malicious job leaves backdoor in persistent runner state
   - Subsequent legitimate jobs execute backdoor
   - **Likelihood:** MEDIUM (if runners reused)
   - **Impact:** HIGH

4. **Kernel Exploitation**
   - Agent code exploits Linux kernel vulnerability
   - Breaks out of container isolation
   - Gains root access to GitHub Actions runner
   - **Likelihood:** LOW (requires expert exploit)
   - **Impact:** CRITICAL

5. **Memory Dump Attack**
   - Attacker dumps process memory containing credentials
   - **Likelihood:** LOW (requires runner compromise)
   - **Impact:** CRITICAL

### Trust Boundaries

```
┌─────────────────────────────────────────────────────┐
│ UNTRUSTED ZONE (AI-Generated Code)                  │
│ - Claude-generated Python/JavaScript/Bash           │
│ - Can attempt any operation                         │
│ - Assume hostile intent                             │
└─────────────────────────────────────────────────────┘
          │
          │ Container boundary (Phase 1)
          │ Proxy validation (Phase 2)
          │ gVisor syscall interception (Phase 3)
          ↓
┌─────────────────────────────────────────────────────┐
│ TRUSTED ZONE (Infrastructure)                       │
│ - GitHub Actions host                               │
│ - Credential proxy service                          │
│ - GitHub API                                        │
│ - Anthropic API                                     │
└─────────────────────────────────────────────────────┘
```

### Current Gaps (Pre-Implementation)

See `CRITICAL_SECURITY_FINDINGS.md` for detailed analysis. Summary:

| Gap | Severity | Status |
|-----|----------|--------|
| No filesystem isolation | CRITICAL | Phase 1 fixes |
| No network isolation | CRITICAL | Phase 2 fixes |
| Credentials in env vars | CRITICAL | Phase 2 fixes |
| Persistent runner state | HIGH | Phase 1 fixes |
| No syscall filtering | HIGH | Phase 3 fixes |

---

## Phase 1: Docker Containerization

**Timeline:** THIS WEEK (Weeks 1-2)
**Risk Reduction:** 60-70%
**Engineering Effort:** 3-4 days
**Status:** APPROVED - Starting immediately

### Overview

Phase 1 implements container-based isolation using Docker on GitHub Actions. This provides immediate risk reduction with minimal infrastructure changes.

### Technical Design

#### Dockerfile

Location: `/Users/barnent1/Projects/sentra/.claude/docker/Dockerfile`

```dockerfile
FROM ubuntu:22.04

# Minimize attack surface - only essential tools
RUN apt-get update && apt-get install -y --no-install-recommends \
    python3.11 \
    python3-pip \
    nodejs \
    npm \
    git \
    curl \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN useradd -m -s /bin/bash -u 1000 claude-agent && \
    mkdir -p /home/claude-agent/workspace && \
    chown -R claude-agent:claude-agent /home/claude-agent

# Set working directory
WORKDIR /home/claude-agent/workspace

# Switch to non-root user
USER claude-agent:claude-agent

# Configure PATH for user-installed packages
ENV PATH="/home/claude-agent/.local/bin:$PATH"

# Pre-install Python dependencies
RUN pip install --user --no-cache-dir anthropic requests

# Entrypoint runs the AI agent worker
ENTRYPOINT ["python3.11", ".claude/scripts/ai-agent-worker.py"]
```

#### GitHub Actions Workflow

Location: `.github/workflows/ai-agent.yml`

```yaml
name: AI Agent Worker

on:
  issues:
    types: [labeled]

jobs:
  ai-agent-work:
    if: github.event.label.name == 'ai-feature'
    runs-on: ubuntu-latest

    # NEW: Container with security options
    container:
      image: ghcr.io/barnent1/sentra-ai-agent:latest
      options: |
        --rm
        --read-only
        --tmpfs /tmp:rw,noexec,nosuid,size=2g
        --tmpfs /run:rw,noexec,nosuid,size=100m
        --cap-drop=ALL
        --cap-add=CHOWN
        --cap-add=SETUID
        --cap-add=SETGID
        --security-opt=no-new-privileges:true
        --pids-limit=100
        --memory=2g
        --memory-swap=2g
        --cpus=2
        --oom-kill-disable=false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run AI Agent
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3.11 .claude/scripts/ai-agent-worker.py \
            ${{ github.event.issue.number }}
```

### Security Features

#### 1. Read-Only Root Filesystem

**Implementation:** `--read-only` flag

**Protection:**
- Agent cannot modify system files
- Cannot install packages system-wide
- Cannot persist malware between jobs
- Only `/tmp` and `/run` are writable (as tmpfs)

**Verification:**
```bash
# Should fail
docker run --rm sentra-ai-agent:latest touch /etc/test.txt
# Expected: "Read-only file system"
```

#### 2. Non-Root User Execution

**Implementation:** `USER claude-agent:claude-agent` in Dockerfile

**Protection:**
- Cannot exploit setuid binaries
- Cannot bind to privileged ports (< 1024)
- Cannot access other users' files
- Limited blast radius if compromised

**Verification:**
```bash
docker run --rm sentra-ai-agent:latest whoami
# Expected: "claude-agent"
```

#### 3. Capability Dropping

**Implementation:** `--cap-drop=ALL` with minimal additions

**Capabilities Added Back:**
- `CAP_CHOWN` - Required for git operations
- `CAP_SETUID/CAP_SETGID` - Required for subprocess execution

**Capabilities Removed:**
- `CAP_NET_ADMIN` - Cannot modify network config
- `CAP_SYS_ADMIN` - Cannot mount filesystems
- `CAP_SYS_PTRACE` - Cannot debug other processes
- All other dangerous capabilities

**Verification:**
```bash
docker run --rm sentra-ai-agent:latest capsh --print
# Should show minimal capability set
```

#### 4. Process and Memory Limits

**Implementation:** cgroups via Docker options

**Limits:**
- Max processes: 100 (prevents fork bombs)
- Max memory: 2GB (prevents OOM attacks)
- Max CPU: 2 cores (prevents resource hogging)
- No swap (predictable performance)

**Verification:**
```bash
# Fork bomb should be killed
docker run --rm --pids-limit=10 sentra-ai-agent:latest \
  bash -c 'for i in {1..100}; do ( sleep infinity ) & done'
# Expected: "Resource temporarily unavailable"

# Memory hog should be OOM killed
docker run --rm --memory=100m sentra-ai-agent:latest \
  python3 -c "a = [0] * 10**9"
# Expected: "Killed"
```

#### 5. Ephemeral /tmp Filesystem

**Implementation:** `--tmpfs /tmp:rw,noexec,nosuid,size=2g`

**Protection:**
- In-memory only (no disk persistence)
- `noexec` prevents executing binaries from /tmp
- `nosuid` prevents setuid escalation
- Automatic cleanup when container terminates

**Verification:**
```bash
# Should fail to execute
docker run --rm sentra-ai-agent:latest \
  bash -c 'echo "#!/bin/sh" > /tmp/test.sh && chmod +x /tmp/test.sh && /tmp/test.sh'
# Expected: "Permission denied"
```

### Limitations

Phase 1 does NOT provide:
- Network isolation (agents can still connect to arbitrary domains)
- Credential isolation (still in environment variables)
- Kernel-level isolation (still uses host kernel)

**These are addressed in Phase 2 and Phase 3.**

### Deliverables

- [ ] Dockerfile for AI agent runtime
- [ ] Updated workflow YAML with container directive
- [ ] Container image build pipeline
- [ ] Security verification test suite
- [ ] Documentation and runbooks

---

## Phase 2: Credential Proxy Service

**Timeline:** Weeks 2-4 (immediately after Phase 1)
**Risk Reduction:** 30% (CRITICAL - prevents credential theft)
**Engineering Effort:** 4-5 days
**Status:** APPROVED - Starts after Phase 1

### Overview

Phase 2 eliminates credential exposure by implementing a sidecar proxy service. Credentials remain on the GitHub Actions host and are never passed into the container environment.

### Architecture

```
┌──────────────────────────────────────────────────────┐
│ GitHub Actions Runner (Host)                         │
│                                                       │
│  ┌────────────────────────────────────────────────┐ │
│  │ Credential Proxy Service                       │ │
│  │ (Host Process - Python)                        │ │
│  │                                                 │ │
│  │ - Listens on Unix socket                       │ │
│  │ - Validates all requests                       │ │
│  │ - Attaches credentials if approved             │ │
│  │ - Logs all access (audit trail)                │ │
│  │ - Credentials stored in memory only            │ │
│  └────────────────────────────────────────────────┘ │
│         ↑                                            │
│         │ /var/run/credential-proxy.sock            │
│         │ (Unix domain socket)                       │
│         ↓                                            │
│  ┌────────────────────────────────────────────────┐ │
│  │ Docker Container (Isolated)                    │ │
│  │                                                 │ │
│  │ AI Agent Code:                                 │ │
│  │ - NO $GITHUB_TOKEN in environment              │ │
│  │ - NO $ANTHROPIC_API_KEY in environment        │ │
│  │ - Requests: "Clone github.com/user/repo"      │ │
│  │ - Proxy validates + attaches real token       │ │
│  │ - Agent never sees actual credentials         │ │
│  └────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────┘
```

### Technical Design

#### Credential Proxy Service

Location: `.claude/services/credential-proxy.py`

```python
#!/usr/bin/env python3
"""
Credential Proxy Service for Sentra AI Agents

This service runs on the GitHub Actions host (outside container) and
provides validated access to credentials. The containerized agent
never has direct access to credentials.

Security properties:
- Credentials stored in host memory only
- All requests logged for audit trail
- Request validation before credential attachment
- Automatic cleanup on termination
"""

import json
import socket
import subprocess
import os
import sys
from pathlib import Path
from typing import Optional, Dict, Any
from datetime import datetime
import logging

class CredentialProxy:
    """
    Validates and provides credentials to sandboxed agent.
    Runs as host process, not inside container.
    """

    def __init__(self, socket_path: str = "/var/run/credential-proxy.sock"):
        self.socket_path = socket_path
        self.audit_log = Path("/tmp/credential-audit.log")

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(message)s',
            handlers=[
                logging.FileHandler(self.audit_log),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(__name__)

        # Define allowed operations per service
        self.allowed_operations = {
            "github": {
                "clone": {"description": "Clone repository", "scopes": ["repo"]},
                "push": {"description": "Push commits", "scopes": ["repo"]},
                "pull": {"description": "Pull changes", "scopes": ["repo"]},
                "create_pr": {"description": "Create pull request", "scopes": ["repo"]},
                "comment": {"description": "Comment on issue", "scopes": ["repo"]},
            },
            "anthropic": {
                "api_call": {"description": "Call Anthropic API", "scopes": ["default"]},
            }
        }

    def validate_request(self, request: Dict[str, Any]) -> tuple[bool, Optional[str]]:
        """
        Validate if request is allowed.

        Returns:
            (is_valid, error_message)
        """
        service = request.get("service")
        operation = request.get("operation")

        if not service or not operation:
            return False, "Missing service or operation"

        if service not in self.allowed_operations:
            return False, f"Unknown service: {service}"

        if operation not in self.allowed_operations[service]:
            return False, f"Operation not allowed: {service}/{operation}"

        # Additional validation could include:
        # - Rate limiting per service
        # - Time-based restrictions
        # - Repository whitelist/blacklist
        # - User authorization

        return True, None

    def get_credential(self, service: str) -> Optional[str]:
        """
        Get credential from secure location.

        Credentials are:
        - For GitHub: Retrieved from gh CLI (uses GITHUB_TOKEN env)
        - For Anthropic: Retrieved from environment variable
        - Never stored on disk
        - Only in memory
        """
        if service == "github":
            try:
                # Use GitHub CLI to get token
                # This ensures proper authentication flow
                result = subprocess.run(
                    ["gh", "auth", "token"],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                if result.returncode == 0:
                    token = result.stdout.strip()
                    # Validate token format
                    if token.startswith(("ghp_", "gho_", "ghu_", "ghs_", "ghr_")):
                        return token
                    else:
                        self.logger.error("Invalid GitHub token format")
                        return None
                else:
                    self.logger.error(f"gh CLI error: {result.stderr}")
                    return None
            except subprocess.TimeoutExpired:
                self.logger.error("gh CLI timeout")
                return None
            except Exception as e:
                self.logger.error(f"Failed to get GitHub token: {e}")
                return None

        elif service == "anthropic":
            # From environment (only accessible to host process)
            token = os.getenv("ANTHROPIC_API_KEY")
            if token and token.startswith("sk-ant-"):
                return token
            else:
                self.logger.error("Invalid or missing ANTHROPIC_API_KEY")
                return None

        return None

    def log_audit(self, request: Dict[str, Any], status: str, error: Optional[str] = None) -> None:
        """
        Log credential access for audit trail.

        This creates a complete audit trail of all credential usage
        for security monitoring and compliance.
        """
        entry = {
            "timestamp": datetime.now().isoformat(),
            "service": request.get("service"),
            "operation": request.get("operation"),
            "status": status,
            "requester_pid": request.get("pid", "unknown"),
            "error": error
        }

        self.logger.info(f"Credential request: {json.dumps(entry)}")

    def handle_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """
        Handle credential request from container.

        Returns response with either credential or error.
        """
        # Validate request
        valid, error = self.validate_request(request)
        if not valid:
            self.log_audit(request, "REJECTED", error)
            return {"error": error, "status": "rejected"}

        # Get credential
        service = request["service"]
        token = self.get_credential(service)

        if not token:
            self.log_audit(request, "FAILED_TO_RETRIEVE")
            return {"error": "Failed to retrieve credential", "status": "error"}

        # Log successful retrieval
        self.log_audit(request, "GRANTED")

        return {
            "status": "granted",
            "token": token,
            "expires_in": 3600,  # 1 hour (informational)
        }

    def start(self):
        """Start the proxy service and listen for requests."""
        # Remove old socket if exists
        if os.path.exists(self.socket_path):
            os.remove(self.socket_path)

        # Create Unix socket
        server_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        server_socket.bind(self.socket_path)

        # Set permissions (only owner can access)
        os.chmod(self.socket_path, 0o600)

        server_socket.listen(5)
        self.logger.info(f"Credential proxy listening on {self.socket_path}")

        try:
            while True:
                client_socket, _ = server_socket.accept()
                try:
                    # Receive request
                    data = client_socket.recv(4096).decode('utf-8')
                    if not data:
                        continue

                    request = json.loads(data)

                    # Handle request
                    response = self.handle_request(request)

                    # Send response
                    client_socket.send(json.dumps(response).encode('utf-8'))

                except json.JSONDecodeError:
                    error_response = {"error": "Invalid JSON", "status": "error"}
                    client_socket.send(json.dumps(error_response).encode('utf-8'))

                except Exception as e:
                    self.logger.error(f"Error handling request: {e}")
                    error_response = {"error": str(e), "status": "error"}
                    client_socket.send(json.dumps(error_response).encode('utf-8'))

                finally:
                    client_socket.close()

        except KeyboardInterrupt:
            self.logger.info("Shutting down credential proxy")

        finally:
            server_socket.close()
            if os.path.exists(self.socket_path):
                os.remove(self.socket_path)

def main():
    proxy = CredentialProxy()
    proxy.start()

if __name__ == "__main__":
    main()
```

#### Agent Integration

Location: `.claude/scripts/ai-agent-worker.py` (modified)

```python
# In AgentWorker class

def __init__(self, issue_number: int):
    self.issue_number = issue_number
    self.credential_socket = "/var/run/credential-proxy.sock"

    # DON'T load credentials directly
    # They're not available in container environment

def get_credential(self, service: str, operation: str) -> str:
    """
    Request credential from proxy service.

    Args:
        service: "github" or "anthropic"
        operation: Specific operation (e.g., "clone", "push", "api_call")

    Returns:
        Credential token

    Raises:
        RuntimeError: If credential request denied or proxy unavailable
    """
    try:
        with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as sock:
            sock.connect(self.credential_socket)

            request = {
                "service": service,
                "operation": operation,
                "pid": os.getpid(),
            }

            sock.send(json.dumps(request).encode('utf-8'))
            response_data = sock.recv(4096).decode('utf-8')
            response = json.loads(response_data)

            if response.get("status") == "granted":
                return response["token"]
            else:
                error = response.get("error", "Unknown error")
                raise RuntimeError(f"Credential request denied: {error}")

    except socket.error as e:
        raise RuntimeError(f"Cannot connect to credential proxy: {e}")
    except json.JSONDecodeError as e:
        raise RuntimeError(f"Invalid response from credential proxy: {e}")

# Usage example
def clone_repository(self, repo_url: str):
    """Clone repository using proxy-provided credentials."""
    token = self.get_credential("github", "clone")

    # Use token in git operation
    authenticated_url = repo_url.replace(
        "https://github.com/",
        f"https://x-access-token:{token}@github.com/"
    )

    subprocess.run(["git", "clone", authenticated_url], check=True)
```

#### Updated Workflow

```yaml
jobs:
  ai-agent-work:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Start credential proxy
        run: |
          # Start proxy in background on HOST (not in container)
          python3 .claude/services/credential-proxy.py &
          PROXY_PID=$!
          echo "PROXY_PID=$PROXY_PID" >> $GITHUB_ENV

          # Wait for socket creation
          for i in {1..30}; do
            if [ -S /var/run/credential-proxy.sock ]; then
              echo "Credential proxy started successfully"
              break
            fi
            sleep 0.5
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

      - name: Run AI Agent in container
        run: |
          docker run --rm \
            --read-only \
            --tmpfs /tmp:rw,noexec,nosuid,size=2g \
            --mount type=bind,source=/var/run/credential-proxy.sock,target=/var/run/credential-proxy.sock,readonly \
            --cap-drop=ALL \
            --pids-limit=100 \
            --memory=2g \
            --cpus=2 \
            -v ${{ github.workspace }}:/home/claude-agent/workspace:ro \
            sentra-ai-agent:latest \
            ${{ github.event.issue.number }}

      - name: Cleanup credential proxy
        if: always()
        run: |
          if [ -n "$PROXY_PID" ]; then
            kill $PROXY_PID || true
          fi
          rm -f /var/run/credential-proxy.sock
```

### Security Properties

1. **Credentials Never in Container**
   - No `$GITHUB_TOKEN` or `$ANTHROPIC_API_KEY` in container environment
   - Agent cannot access credentials directly
   - Even if compromised, attacker cannot extract credentials

2. **Request Validation**
   - All credential requests validated before approval
   - Whitelist of allowed operations
   - Can implement rate limiting, time restrictions, etc.

3. **Complete Audit Trail**
   - Every credential request logged
   - Timestamp, service, operation, status
   - Enables security monitoring and compliance

4. **Defense in Depth**
   - Even if agent code is malicious, proxy validates requests
   - Proxy runs outside container with full credentials
   - Container breach does not compromise credentials

### Verification

```bash
# Test 1: Credentials not in container environment
docker run --rm sentra-ai-agent:latest env | grep -E "(GITHUB_TOKEN|ANTHROPIC_API_KEY)"
# Expected: No output

# Test 2: Proxy socket accessible from container
docker run --rm -v /var/run/credential-proxy.sock:/var/run/credential-proxy.sock \
  sentra-ai-agent:latest ls -la /var/run/credential-proxy.sock
# Expected: Socket exists

# Test 3: Invalid request rejected
# (Requires proxy running and test client)
```

### Deliverables

- [ ] Credential proxy service implementation
- [ ] Agent integration (updated ai-agent-worker.py)
- [ ] Updated workflow YAML
- [ ] Audit log analysis tools
- [ ] Documentation and security runbooks

---

## Phase 3: gVisor Migration

**Timeline:** Q1 2026 (Months 2-3)
**Risk Reduction:** 15% (remaining gap to match Claude Code for Web)
**Engineering Effort:** 15-20 days
**Status:** APPROVED - Planning in Q4 2025

### Overview

Phase 3 migrates from Docker containers on GitHub Actions to custom infrastructure running gVisor. This provides industry-leading security by eliminating direct host kernel access.

### What is gVisor?

gVisor is Google's open-source container runtime sandbox:

- **User-space kernel** written in Go
- Implements Linux system call interface without hardware virtualization
- All syscalls intercepted by "Sentry" (gVisor's kernel)
- Only ~50 syscalls passed through to host kernel (vs. ~300+ for Docker)
- Prevents kernel exploitation attacks

**Architecture:**

```
Application
    ↓
  syscall
    ↓
Sentry (gVisor user-space kernel)
    ↓ (interprets syscall)
    ↓
  Gofer (filesystem proxy)
    ↓
Host Kernel (minimal syscall subset)
```

### Why gVisor?

| Feature | Docker | gVisor | Benefit |
|---------|--------|--------|---------|
| Syscall exposure | ~300 | ~50 | 83% reduction in attack surface |
| Kernel vulnerability | Exploitable | Protected | Prevents privilege escalation |
| Startup time | <1s | 1-2s | Acceptable overhead |
| Compatibility | 100% | 95% | Good enough for Sentra |
| Operations | Simple | Complex | Worth it for security |

### Requirements

Phase 3 requires **custom infrastructure** because:
1. GitHub Actions does not support gVisor runtime
2. Need control over container orchestration
3. Requires gVisor-specific configuration
4. Need dedicated compute resources

### High-Level Design

**Infrastructure:**
- Custom EC2/GCP instances with gVisor installed
- Self-hosted GitHub Actions runners
- Container orchestration (simple queue system)
- Monitoring and alerting

**Migration Path:**
1. Set up gVisor infrastructure (weeks 1-2)
2. Deploy self-hosted runners (week 3)
3. Test workflow compatibility (week 4)
4. Gradual migration from GitHub-hosted to self-hosted
5. Decommission GitHub-hosted runners

### Deliverables (Deferred to Q1 2026)

- [ ] Infrastructure design document
- [ ] Cost analysis and budgeting
- [ ] gVisor infrastructure deployment
- [ ] Self-hosted runner setup
- [ ] Migration playbook
- [ ] Security validation

**Note:** Detailed design will be created in Q4 2025 during planning phase.

---

## Infrastructure Architecture

### Phase 1-2: GitHub Actions

```
┌─────────────────────────────────────────────────────┐
│ GitHub Actions (Hosted by GitHub)                   │
│                                                      │
│  ┌────────────────────────────────────────────────┐│
│  │ ubuntu-latest runner                           ││
│  │                                                 ││
│  │  ┌──────────────────────────────────────────┐ ││
│  │  │ Credential Proxy (Host Process)          │ ││
│  │  │ - Stores credentials                     │ ││
│  │  │ - Validates requests                     │ ││
│  │  └──────────────────────────────────────────┘ ││
│  │       ↕ (Unix socket)                          ││
│  │  ┌──────────────────────────────────────────┐ ││
│  │  │ Docker Container                         │ ││
│  │  │ - AI agent code                          │ ││
│  │  │ - No credentials                         │ ││
│  │  │ - Isolated filesystem                    │ ││
│  │  └──────────────────────────────────────────┘ ││
│  └────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────┘
```

**Advantages:**
- No infrastructure to manage
- Automatic scaling
- Free for public repositories
- Fast setup

**Limitations:**
- Cannot use gVisor
- Limited control over runner environment
- Potential runner reuse (mitigated by container isolation)

### Phase 3: Custom Infrastructure

```
┌─────────────────────────────────────────────────────┐
│ Custom Compute (EC2/GCP)                            │
│                                                      │
│  ┌────────────────────────────────────────────────┐│
│  │ Self-Hosted Runner                             ││
│  │                                                 ││
│  │  ┌──────────────────────────────────────────┐ ││
│  │  │ gVisor Runtime                           │ ││
│  │  │ - User-space kernel                      │ ││
│  │  │ - Syscall interception                   │ ││
│  │  │ - Gofer filesystem proxy                 │ ││
│  │  │                                           │ ││
│  │  │  ┌────────────────────────────────────┐ │ ││
│  │  │  │ Sandbox Container                  │ │ ││
│  │  │  │ - AI agent code                    │ │ ││
│  │  │  │ - Complete isolation               │ │ ││
│  │  │  └────────────────────────────────────┘ │ ││
│  │  └──────────────────────────────────────────┘ ││
│  └────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────┘
```

**Advantages:**
- Industry-leading security (gVisor)
- Complete control over environment
- Dedicated resources
- Predictable performance

**Limitations:**
- Infrastructure to manage
- Monthly costs (estimate: $200-500/month)
- More complex operations

---

## SDK Implementation

### Current Approach (Incorrect)

Sentra currently uses CLI subprocess invocation:

```python
# DON'T DO THIS
process = subprocess.Popen([
    "claude-code",
    "--api-key", api_key,
    "--yes"
])
stdout, stderr = process.communicate(input=prompt)
# Parse stdout/stderr (fragile!)
```

**Problems:**
- Fragile output parsing
- No structured error handling
- No automatic context management
- No tool ecosystem
- Inefficient token usage

### Approved Approach: Anthropic Python SDK

**Decision:** Use Anthropic Python SDK directly with tool use patterns.

**Example:**

```python
from anthropic import Anthropic

class SentraAgent:
    def __init__(self, api_key: str):
        self.client = Anthropic(api_key=api_key)
        self.conversation_history = []

    async def execute_issue(self, issue: dict) -> dict:
        """Execute GitHub issue using Claude with tool use."""

        # Build system prompt with project context
        system_prompt = self._build_system_prompt(issue)

        # Initial user message
        self.conversation_history.append({
            "role": "user",
            "content": self._build_issue_prompt(issue)
        })

        # Agent loop with tool use
        while True:
            response = await self.client.messages.create(
                model="claude-sonnet-4.5",
                max_tokens=8192,
                system=system_prompt,
                messages=self.conversation_history,
                tools=[
                    {
                        "name": "read_file",
                        "description": "Read contents of a file",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "path": {"type": "string"}
                            },
                            "required": ["path"]
                        }
                    },
                    {
                        "name": "write_file",
                        "description": "Write contents to a file",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "path": {"type": "string"},
                                "content": {"type": "string"}
                            },
                            "required": ["path", "content"]
                        }
                    },
                    {
                        "name": "run_command",
                        "description": "Execute shell command",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "command": {"type": "string"}
                            },
                            "required": ["command"]
                        }
                    }
                ]
            )

            # Add assistant response to history
            self.conversation_history.append({
                "role": "assistant",
                "content": response.content
            })

            # Handle stop reasons
            if response.stop_reason == "tool_use":
                # Extract tool calls
                tool_results = await self._execute_tools(response.content)

                # Add tool results to history
                self.conversation_history.append({
                    "role": "user",
                    "content": tool_results
                })

            elif response.stop_reason == "end_turn":
                # Task complete
                return {
                    "status": "success",
                    "output": self._extract_output(response.content)
                }

            elif response.stop_reason == "max_tokens":
                # Context limit reached - implement compaction
                await self._compact_context()

            else:
                # Error or unexpected stop reason
                return {
                    "status": "error",
                    "reason": response.stop_reason
                }

    async def _execute_tools(self, content: list) -> list:
        """Execute tools requested by Claude."""
        results = []

        for block in content:
            if block.type == "tool_use":
                tool_name = block.name
                tool_input = block.input

                # Execute tool
                if tool_name == "read_file":
                    result = self._read_file(tool_input["path"])
                elif tool_name == "write_file":
                    result = self._write_file(tool_input["path"], tool_input["content"])
                elif tool_name == "run_command":
                    result = self._run_command(tool_input["command"])
                else:
                    result = {"error": f"Unknown tool: {tool_name}"}

                results.append({
                    "type": "tool_result",
                    "tool_use_id": block.id,
                    "content": json.dumps(result)
                })

        return results

    async def _compact_context(self):
        """Compact conversation history when approaching token limit."""
        # Summarize old messages
        summary = await self._summarize_history(self.conversation_history[:10])

        # Replace old messages with summary
        self.conversation_history = [
            {"role": "user", "content": f"Previous context: {summary}"},
            *self.conversation_history[10:]
        ]
```

**Benefits:**
- Structured tool use (no output parsing)
- Automatic context management
- Better error handling
- Token usage optimization
- Future-proof

**Migration Timeline:** Phase 2 (Weeks 2-4)

---

## Security Testing

### Phase 1 Tests

**Filesystem Isolation:**
```bash
# Test 1: Cannot modify /etc
docker run --rm sentra-ai-agent:latest touch /etc/test.txt
# Expected: "Read-only file system"

# Test 2: Can write to /tmp
docker run --rm sentra-ai-agent:latest bash -c 'echo test > /tmp/test.txt && cat /tmp/test.txt'
# Expected: "test"

# Test 3: /tmp is not executable
docker run --rm sentra-ai-agent:latest bash -c 'echo "#!/bin/sh" > /tmp/test.sh && chmod +x /tmp/test.sh && /tmp/test.sh'
# Expected: "Permission denied"
```

**Process Limits:**
```bash
# Test 4: Fork bomb killed
docker run --rm --pids-limit=10 sentra-ai-agent:latest bash -c 'for i in {1..100}; do ( sleep infinity ) & done'
# Expected: "Resource temporarily unavailable"

# Test 5: Memory limit enforced
docker run --rm --memory=100m sentra-ai-agent:latest python3 -c "a = [0] * 10**9"
# Expected: "Killed" (OOM)
```

**Capability Tests:**
```bash
# Test 6: Cannot bind privileged port
docker run --rm sentra-ai-agent:latest python3 -c "import socket; s = socket.socket(); s.bind(('', 80))"
# Expected: "Permission denied"

# Test 7: Non-root user
docker run --rm sentra-ai-agent:latest whoami
# Expected: "claude-agent"
```

### Phase 2 Tests

**Credential Isolation:**
```bash
# Test 1: Credentials not in environment
docker run --rm sentra-ai-agent:latest env | grep -E "(GITHUB_TOKEN|ANTHROPIC_API_KEY)"
# Expected: No output

# Test 2: Proxy socket accessible
docker run --rm -v /var/run/credential-proxy.sock:/var/run/credential-proxy.sock sentra-ai-agent:latest test -S /var/run/credential-proxy.sock
# Expected: Success (exit code 0)

# Test 3: Can request credential via proxy
# (Requires integration test with proxy running)
```

**Audit Trail:**
```bash
# Test 4: All requests logged
# Check /tmp/credential-audit.log for entries
cat /tmp/credential-audit.log | jq .
# Expected: JSON log entries with timestamps, services, operations
```

### Phase 3 Tests

**gVisor Isolation:**
```bash
# Test 1: Syscall interception
# (Requires custom test harness)

# Test 2: Kernel exploit mitigation
# (Requires security audit team)
```

### Automated Test Suite

Location: `.claude/tests/security/`

```python
# test_container_security.py
import subprocess
import pytest

def test_filesystem_read_only():
    """Verify root filesystem is read-only."""
    result = subprocess.run(
        ["docker", "run", "--rm", "sentra-ai-agent:latest", "touch", "/etc/test.txt"],
        capture_output=True
    )
    assert result.returncode != 0
    assert b"Read-only file system" in result.stderr

def test_tmp_writable():
    """Verify /tmp is writable but not executable."""
    result = subprocess.run(
        ["docker", "run", "--rm", "sentra-ai-agent:latest",
         "bash", "-c", "echo test > /tmp/test.txt && cat /tmp/test.txt"],
        capture_output=True
    )
    assert result.returncode == 0
    assert b"test" in result.stdout

def test_tmp_not_executable():
    """Verify /tmp has noexec flag."""
    result = subprocess.run(
        ["docker", "run", "--rm", "sentra-ai-agent:latest",
         "bash", "-c", 'echo "#!/bin/sh\necho hello" > /tmp/test.sh && chmod +x /tmp/test.sh && /tmp/test.sh'],
        capture_output=True
    )
    assert result.returncode != 0
    assert b"Permission denied" in result.stderr

def test_process_limit():
    """Verify process limit enforced."""
    result = subprocess.run(
        ["docker", "run", "--rm", "--pids-limit=10", "sentra-ai-agent:latest",
         "bash", "-c", "for i in {1..100}; do ( sleep infinity ) & done"],
        capture_output=True,
        timeout=5
    )
    assert result.returncode != 0

def test_memory_limit():
    """Verify memory limit enforced."""
    result = subprocess.run(
        ["docker", "run", "--rm", "--memory=100m", "sentra-ai-agent:latest",
         "python3", "-c", "a = [0] * 10**9"],
        capture_output=True,
        timeout=10
    )
    assert result.returncode != 0  # Killed by OOM

def test_non_root_user():
    """Verify running as non-root user."""
    result = subprocess.run(
        ["docker", "run", "--rm", "sentra-ai-agent:latest", "whoami"],
        capture_output=True
    )
    assert result.returncode == 0
    assert b"claude-agent" in result.stdout

def test_no_privileged_port_bind():
    """Verify cannot bind privileged ports."""
    result = subprocess.run(
        ["docker", "run", "--rm", "sentra-ai-agent:latest",
         "python3", "-c", "import socket; s = socket.socket(); s.bind(('', 80))"],
        capture_output=True
    )
    assert result.returncode != 0
    assert b"Permission denied" in result.stderr

# Run tests:
# pytest .claude/tests/security/test_container_security.py -v
```

---

## Timeline and Milestones

### Week 1: Phase 1 Start (THIS WEEK)

**Days 1-2:**
- [ ] Create Dockerfile
- [ ] Set up container image build pipeline (GitHub Container Registry)
- [ ] Test Docker image locally

**Days 3-4:**
- [ ] Update workflow YAML with container directive
- [ ] Deploy to test branch
- [ ] Run security verification tests

**Day 5:**
- [ ] Deploy to main branch (behind feature flag if needed)
- [ ] Monitor first production run
- [ ] Document any issues

**Milestone:** Phase 1 complete - 60-70% risk reduction achieved

### Week 2: Phase 1 Polish

**Days 6-7:**
- [ ] Fine-tune resource limits based on monitoring
- [ ] Optimize Dockerfile for faster builds
- [ ] Create security runbooks
- [ ] Team training on new architecture

**Milestone:** Phase 1 stable and documented

### Weeks 3-4: Phase 2 Implementation

**Days 8-10:**
- [ ] Implement credential proxy service
- [ ] Unit tests for proxy
- [ ] Integration with workflow

**Days 11-13:**
- [ ] Update agent code to use proxy
- [ ] End-to-end testing
- [ ] Security verification

**Day 14:**
- [ ] Deploy Phase 2 to production
- [ ] Monitor audit logs
- [ ] Verify credentials isolated

**Milestone:** Phase 2 complete - 85% risk reduction achieved (production-ready)

### Q4 2025: Phase 3 Planning

**Weeks 8-12:**
- [ ] Design gVisor infrastructure
- [ ] Cost analysis and budgeting
- [ ] Proof-of-concept deployment
- [ ] Create migration plan

**Milestone:** Phase 3 design complete, ready for Q1 2026 implementation

### Q1 2026: Phase 3 Implementation

**Weeks 1-4:**
- [ ] Deploy gVisor infrastructure
- [ ] Set up self-hosted runners
- [ ] Gradual migration from GitHub-hosted
- [ ] Security audit and validation

**Milestone:** Phase 3 complete - Industry-leading security achieved

---

## References

### Research Documents

Located in project root directory:

1. **CRITICAL_SECURITY_FINDINGS.md**
   - Executive summary of security gaps
   - Risk matrix (before/after)
   - Quick win fixes
   - Implementation timeline

2. **ADR_0001_CONTAINER_SECURITY.md**
   - Architecture Decision Record
   - Options analysis
   - Detailed technical design
   - Rollout strategy

3. **TECHNICAL_RESEARCH_CLAUDE_CODE.md**
   - Deep technical analysis (34KB)
   - Claude Code for Web architecture
   - Detailed comparisons
   - Implementation examples

### External Resources

**Claude Code for Web:**
- Official blog: https://claude.com/blog/claude-code-on-the-web
- Engineering blog: https://www.anthropic.com/engineering/claude-code-sandboxing

**gVisor:**
- Official docs: https://gvisor.dev/docs/
- Architecture: https://gvisor.dev/docs/architecture_guide/
- Security model: https://gvisor.dev/docs/security/

**Anthropic SDK:**
- Python SDK: https://github.com/anthropics/anthropic-sdk-python
- Tool use guide: https://docs.anthropic.com/claude/docs/tool-use
- Best practices: https://docs.anthropic.com/claude/docs/agentic-best-practices

**Docker Security:**
- Security best practices: https://docs.docker.com/engine/security/
- AppArmor/SELinux: https://docs.docker.com/engine/security/apparmor/
- Seccomp profiles: https://docs.docker.com/engine/security/seccomp/

---

## Approval and Sign-Off

**Approved By:** Glen Barnhardt (Technical Lead)
**Approval Date:** November 12, 2025
**Implementation Status:** APPROVED - Starting This Week

**Phase 1:** Approved for immediate implementation
**Phase 2:** Approved, starts after Phase 1
**Phase 3:** Approved, planning in Q4 2025, implementation Q1 2026

**Next Review:** December 12, 2025 (or after Phase 1 completion)

---

**Document Created By:** Glen Barnhardt with Claude Code
**Last Updated:** November 12, 2025
**Version:** 1.0

---

*This document is the authoritative source for Sentra's AI agent security architecture. All implementation must follow this design unless explicitly approved by Glen Barnhardt.*
